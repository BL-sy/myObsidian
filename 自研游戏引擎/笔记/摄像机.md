---
title: 摄像机
date: 2025-11-17
tags:
  - 自研游戏引擎
  - Cpp
category: 游戏引擎
description:
---
---



## 一、核心定位：Camera 的双重角色

Camera 是引擎中连接**GamePlay（游戏逻辑）** 与**渲染系统** 的关键组件，核心价值体现在两方面：

1. **GamePlay 交互**：响应玩家输入（移动、旋转、缩放），记录自身位置（Position）和旋转（Rotation），是玩家 “观察世界的窗口”；
2. **渲染支撑**：通过自身属性计算 View 矩阵和 Projection 矩阵（合称 VP 矩阵），提供给 Renderer 作为全局渲染参数，决定顶点如何从模型空间转换到屏幕空间。

其本质并非 “实体对象”，而是**VP 矩阵的生成器与管理者**—— 所有渲染物体共享同一相机的 VP 矩阵，仅模型矩阵（Model）因物体不同而变化。

## 二、核心原理：矩阵逻辑与坐标转换

### 2.1 Camera 的 View 矩阵生成逻辑

相机的 transform（位置 + 旋转）与物体 transform 逻辑互逆：

- 物体移动：直接应用 transform 矩阵（如向右移 = X 轴正方向偏移）；
- 相机移动：本质是 “世界反向移动”（相机向左移 = 世界向右移）。

因此：
```cpp
// View矩阵 = 相机transform矩阵的逆矩阵（仅需位置和旋转，无缩放）
ViewMatrix = Inverse(Camera::GetTransformMatrix());
```

### 2.2 MVP 矩阵的归属分配

顶点从模型空间到屏幕空间的计算流程：

glsl
```glsl
gl_Position = Projection * View * Model * VertexPosition;
```

各部分归属明确，避免逻辑混乱：

|矩阵 / 变量|归属主体|核心作用|
|---|---|---|
|Projection * View（VP 矩阵）|Camera|统一管理视角和投影规则，所有物体共享|
|Model|游戏物体（Object）|描述物体在世界空间的位置 / 旋转 / 缩放|
|VertexPosition|网格（Mesh）|顶点的局部坐标（固定不变）|

## 三、架构设计：Camera 与 Renderer 的交互核心

### 3.1 关键交互：Camera 作为 BeginScene 的参数

Renderer 的`BeginScene`函数负责初始化每帧渲染环境（相机、灯光等），需接收 Camera 作为参数，核心设计要点：

```cpp
// Renderer类静态函数：初始化场景渲染环境
static void Renderer::BeginScene(Camera camera); // 传值而非传引用
```

### 3.2 传值 vs 传引用：多线程渲染下的关键选择

为何选择**传值传递**而非更高效的引用传递？核心原因是**多线程渲染的线程安全**：

- 多线程架构中，`BeginScene`会被封装为渲染命令，存入`RenderCommandQueue`，由独立渲染线程执行；
- 若传递引用（含`const&`）：渲染线程持有 Camera 的引用，而主线程（GamePlay 线程）可能实时修改 Camera 属性（如玩家移动导致位置变化），导致渲染时 VP 矩阵与实际 Camera 状态不一致，引发画面错乱；
- 若传递值：`BeginScene`会复制一份 Camera 的快照（当前位置、旋转、FOV 等），渲染线程使用的是固定副本，即使主线程修改 Camera，也不会影响正在执行的渲染流程，保证数据一致性。

### 3.3 核心流程梳理（Game Loop 中）

```cpp
while (m_Running) {

	// set camera position before begin scene so matrix reflects new position
	m_Camera.SetPosition({ 0.5f, 0.5f, 0.5f });

	// 2. 渲染流程（预留Begin/EndScene，当前简化提交）
	Renderer::BeginScene(m_Camera);
	Renderer::Submit(m_Shader, m_VertexArray);
	Renderer::EndScene();

}
```

## 四、Camera 类核心设计要点

### 4.1 核心属性

```cpp
class Camera {
public:
    // 基础属性（影响Projection矩阵）
    float FOV = 60.0f;         // 视场角
    float AspectRatio = 16.0f/9.0f; // 宽高比
    float NearClip = 0.1f;     // 近裁剪面
    float FarClip = 1000.0f;   // 远裁剪面

    // 变换属性（影响View矩阵）
    glm::vec3 Position = glm::vec3(0.0f); // 位置
    glm::vec3 Rotation = glm::vec3(0.0f); // 旋转（欧拉角，无缩放）

    // 核心方法：计算VP矩阵
    glm::mat4 GetViewMatrix() const;
    glm::mat4 GetProjectionMatrix() const;
    inline glm::mat4 GetVPMatrix() const { return GetProjectionMatrix() * GetViewMatrix(); }
};
```

### 4.2 关键方法实现逻辑

```cpp
// 计算View矩阵：transform矩阵的逆矩阵
glm::mat4 Camera::GetViewMatrix() const {
    glm::mat4 transform = glm::translate(glm::mat4(1.0f), Position) * 
                          glm::toMat4(glm::quat(Rotation));
    return glm::inverse(transform); // 相机transform逆矩阵 = View矩阵
}

// 计算Projection矩阵（透视投影示例）
glm::mat4 Camera::GetProjectionMatrix() const {
    return glm::perspective(glm::radians(FOV), AspectRatio, NearClip, FarClip);
}
```

## 总结

Camera 系统的核心设计思路是 “**封装 VP 矩阵生成逻辑，兼顾 GamePlay 交互与多线程渲染安全**”。通过明确矩阵归属、选择值传递参数、隔离 transform 与 View 矩阵，既保证了渲染流程的高效性，又为引擎的多线程扩展和功能迭代预留了充足空间，是连接游戏逻辑与渲染管线的关键枢纽。