---
title: 摄像机
date: 2025-11-18
tags:
  - 自研游戏引擎
  - Cpp
category: 游戏引擎
description:
---
---


# 游戏引擎架构优化：业务与引擎核心的彻底解耦之路

在游戏引擎开发初期，我们常为了快速实现功能而忽略架构设计 —— 把引擎核心逻辑和游戏业务代码混在一起，导致后续维护困难、引擎无法复用。最近我对 Hazel 引擎做了一次关键架构优化：将游戏业务逻辑迁移到独立的 Sandbox 项目，扩充 Hazel.h 为统一入口，并新增 Timestep 工具类。今天就来聊聊这次优化的思路、实现和价值。

# 一、优化前的 “痛点”：架构耦合的烦恼

在优化前，Hazel 引擎的`Application`类里混杂着两类完全不同的代码：

- 引擎核心逻辑：窗口创建、事件循环、渲染抽象接口；
- 游戏业务逻辑：三角形 / 矩形的 VAO/VBO 初始化、相机控制、输入响应。

这种耦合带来了两个致命问题：

1. **引擎无法复用**：如果想基于 Hazel 开发新游戏，必须修改`Application`里的业务代码，引擎失去了 “通用框架” 的意义；
2. **维护成本高**：业务迭代（比如新增游戏物体）和引擎升级（比如扩展渲染 API）相互干扰，容易引发连锁 Bug；
3. **开发体验差**：业务层需要逐个引入`Renderer.h`、`OrthographicCamera.h`等分散头文件，繁琐且易出错。

优化的核心目标很明确：**让引擎只做 “通用基础能力”，让业务只关注 “游戏逻辑”，两者彻底解耦**。

# 二、优化核心：三大关键调整

## 1. 业务逻辑迁移：ExampleLayer 承载所有游戏功能

我把原`Application`中的游戏业务逻辑，全部迁移到了独立的`Sandbox`项目的`ExampleLayer`中。`ExampleLayer`是引擎`Layer`系统的子类，作为游戏的核心功能层，统一管理：

## （1）渲染资源初始化

集中创建三角形（带顶点颜色）和矩形（固定蓝色）的渲染资源，包括 VAO、VBO、IBO 和对应的 Shader：

```cpp
// ExampleLayer构造函数核心代码
float vertices[3 * 7] = { /* 顶点位置+颜色数据 */ };
BufferLayout layout = { {ShaderDataType::Float3, "a_Pos"}, {ShaderDataType::Float4, "a_Color"} };
auto vertexBuffer = VertexBuffer::Create(vertices, sizeof(vertices));
vertexBuffer->SetLayout(layout);
auto indexBuffer = IndexBuffer::Create(indices, 3);
m_VertexArray->AddVertexBuffer(vertexBuffer);
m_VertexArray->SetIndexBuffer(indexBuffer);

// 同时创建矩形渲染资源和两个Shader...
```

## （2）相机控制与输入响应

通过 小键盘上下左右控制相机移动、QE 控制相机旋转，结合`Timestep`实现帧率无关的平滑控制：

```cpp
void OnUpdate(Hazel::Timestep ts) override
{
	if (Hazel::Input::IsKeyPressed(HZ_KEY_LEFT))
		m_CameraPosition.x -= m_CameraMoveSpeed * ts;
	else if (Hazel::Input::IsKeyPressed(HZ_KEY_RIGHT))
		m_CameraPosition.x += m_CameraMoveSpeed * ts;

	if (Hazel::Input::IsKeyPressed(HZ_KEY_UP))
		m_CameraPosition.y += m_CameraMoveSpeed * ts;
	else if (Hazel::Input::IsKeyPressed(HZ_KEY_DOWN))
		m_CameraPosition.y -= m_CameraMoveSpeed * ts;

	if (Hazel::Input::IsKeyPressed(HZ_KEY_Q))
		m_CameraRotation += m_CameraRotationSpeed * ts;
	if (Hazel::Input::IsKeyPressed(HZ_KEY_E))
		m_CameraRotation -= m_CameraRotationSpeed * ts;

	// 1. 清屏
	Hazel::RenderCommand::SetClearColor({ 0.1f, 0.1f, 0.1f, 1 });
	Hazel::RenderCommand::Clear();
	
	m_Camera.SetPosition(m_CameraPosition);
	m_Camera.SetRotation(m_CameraRotation);

	// 2. 渲染流程
	Hazel::Renderer::BeginScene(m_Camera);
	// 提交物体
	Hazel::Renderer::Submit(m_BlueShader, m_SquareVA);
	Hazel::Renderer::Submit(m_Shader, m_VertexArray);
	Hazel::Renderer::EndScene();
}
```

## 2. Hazel.h 扩充

```cpp
// Hazel.h 核心内容（扩充后）
#pragma once
// 核心基础
#include "Hazel/Application.h"
#include "Hazel/Layer.h"
#include "Hazel/Log.h"
#include "Hazel/Core/Timestep.h"

// 输入相关
#include "Hazel/Input.h"
#include "Hazel/KeyCodes.h"
#include "Hazel/MouseButtonCodes.h"

// ImGui
#include "Hazel/ImGui/ImGuiLayer.h"

// 渲染核心
#include "Hazel/Renderer/Renderer.h"
#include "Hazel/Renderer/RenderCommand.h"
#include "Hazel/Renderer/Buffer.h"
#include "Hazel/Renderer/Shader.h"
#include "Hazel/Renderer/VertexArray.h"
#include "Hazel/Renderer/OrthographicCamera.h"

// 入口回调
#include "Hazel/EntryPoint.h"
```

业务层`#include <Hazel.h>`，调用所有引擎功能。

## 3. 新增 Timestep：帧率无关的统一更新

为了解决 “高帧率快、低帧率慢” 的问题，我新增了`Timestep`工具类，封装每帧的实际耗时：

```cpp
// Timestep.h
#pragma once
namespace Hazel {
    class Timestep {
    public:
        Timestep(float time = 0.0f) : m_Time(time) {}
        operator float() const { return m_Time; } // 支持隐式转换
        float GetSeconds() const { return m_Time; }
        float GetMilliseconds() const { return m_Time * 1000.0f; }
    private:
        float m_Time; // 每帧耗时（秒）
    };
}
```

使用时，相机移动速度乘以`Timestep`，无论帧率是 60 帧还是 120 帧，移动速度始终一致：

```cpp
m_CameraPosition.x -= m_CameraMoveSpeed * ts; // ts是Timestep实例
```

# 三、架构优势

## 1. 引擎复用性拉满

现在 Hazel 引擎是一个纯粹的 “通用游戏框架”，包含窗口、渲染、输入、Layer 等核心能力。如果要开发新游戏，只需新建一个类似`Sandbox`的项目，通过`CreateApplication()`接入，无需修改引擎一行代码。

## 2. 业务维护更简单

所有游戏逻辑都集中在`ExampleLayer`中，后续新增敌人、碰撞检测、UI 等功能，只需在`Sandbox`项目中扩展 —— 比如新增`UILayer`处理界面，`GameLayer`处理游戏逻辑，通过`PushLayer`叠加，互不干扰。

# 四、总结：架构设计的核心是 “分离关注点”

这次优化没有新增复杂功能，而是通过 “业务与引擎分离、统一入口、工具类封装”，让架构更清晰、更灵活。核心感悟是：

游戏引擎开发中，**“分离关注点” 是永恒的设计原则**—— 引擎只做通用基础能力，业务只做具体游戏逻辑，两者通过抽象接口通信。这样的架构不仅能提升开发效率和维护性，还能让引擎真正成为 “可复用的框架”，为后续的多平台扩展、功能升级打下坚实基础。

# 后续扩展计划

1. 新增`PhysicsLayer`，集成物理引擎（如 Box2D）；
2. 扩展`OrthographicCamera`，支持缩放、跟随目标等功能；
3. 实现`RenderCommandQueue`，支持多线程渲染；
4. 新增`ResourceManager`，统一管理 Shader、纹理等资源。