---
title: 摄像机
date: 2025-11-18
tags:
  - 自研游戏引擎
  - Cpp
category: 游戏引擎
description:
---
---




# 一、核心目标

1. 封装 2D 正交投影 / 视图矩阵逻辑，提供位置、旋转控制接口；
2. 无缝集成现有渲染架构，解耦相机与渲染流程；
3. 预计算矩阵优化性能，适配 2D 游戏、UI 等无透视场景。

# 二、核心实现：OrthographicCamera 类

## 2.1 头文件（OrthographicCamera.h）

```cpp
#pragma once
#include <glm/glm.hpp>

namespace Hazel {
    // 2D正交摄像机：无透视畸变，仅绕Z轴旋转
    class OrthographicCamera
    {
    public:
        // 构造函数：初始化正交投影范围（left/right/bottom/top），Z轴范围[-1,1]
        OrthographicCamera(float left, float right, float bottom, float top);

        // 位置/旋转读写：修改后自动重计算矩阵
        const glm::vec3& GetPosition() const { return m_Position; }
        void SetPosition(const glm::vec3& position) { m_Position = position; RecalculateViewMatrix(); }
        float GetRotation() const { return m_Rotation; }
        void SetRotation(float rotation) { m_Rotation = rotation; RecalculateViewMatrix(); }

        // 矩阵读写：获取预计算的投影/视图/VP矩阵
        const glm::mat4& GetProjectionMatrix() const { return m_ProjectionMatrix; }
        const glm::mat4& GetViewMatrix() const { return m_ViewMatrix; }
        const glm::mat4& GetViewProjectionMatrix() const { return m_ViewProjectionMatrix; }

        // 动态调整投影范围（适配窗口大小变化）

    private:
        // 核心：重计算视图矩阵和VP矩阵
        void RecalculateViewMatrix();
	private:
        glm::mat4 m_ProjectionMatrix;    // 正交投影矩阵
        glm::mat4 m_ViewMatrix;          // 视图矩阵
        glm::mat4 m_ViewProjectionMatrix;// 预计算VP矩阵（Projection * View）
        glm::vec3 m_Position = { 0.0f, 0.0f, 0.0f }; // 相机位置（Z轴用于层叠）
        float m_Rotation = 0.0f;         // 仅绕Z轴旋转（2D场景）
    };
}
```

## 2.2 实现文件（OrthographicCamera.cpp）

```cpp
#include "hzpch.h"
#include "OrthographicCamera.h"
#include <glm/gtc/matrix_transform.hpp>

namespace Hazel {
    OrthographicCamera::OrthographicCamera(float left, float right, float bottom, float top)
    {
        // 生成正交投影矩阵：轴对齐，无透视效果
        m_ProjectionMatrix = glm::ortho(left, right, bottom, top, -1.0f, 1.0f);
        m_ViewMatrix = glm::mat4(1.0f); // 初始视图矩阵为单位矩阵（原点无旋转）
        m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix; // 预计算VP矩阵
    }

    void OrthographicCamera::RecalculateViewMatrix()
    {
        // 1. 构建相机变换矩阵：先旋转（绕Z轴）后平移（符合2D操作直觉）
        glm::mat4 transform = glm::translate(glm::mat4(1.0f), m_Position)
                            * glm::rotate(glm::mat4(1.0f), glm::radians(m_Rotation), glm::vec3(0.0f, 0.0f, 1.0f));
        
        // 2. 视图矩阵 = 相机变换矩阵的逆矩阵
        // 原理：相机移动本质是"世界反向移动"（相机左移=世界右移），逆矩阵实现该逻辑
        m_ViewMatrix = glm::inverse(transform);
        
        // 3. 预计算VP矩阵：避免渲染时重复计算，提升性能
        m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;
    }
}
```

# 三、渲染系统适配：Renderer 集成

## 3.1 Renderer.h

```cpp
#pragma once
#include "RenderCommand.h"
#include "VertexArray.h"
#include "Shader.h"
#include "OrthographicCamera.h"
#include "glm/glm.hpp"

namespace Hazel {
    class Renderer 
    {
    public:
        // 开始场景：缓存相机VP矩阵（全局共享）
        static void BeginScene(const OrthographicCamera& camera);
        // 结束场景：预留优化接口（批处理/排序）
        static void EndScene();
        // 提交渲染：绑定Shader/VA，上传矩阵并绘制
        static void Submit(const std::shared_ptr<Shader>& shader, const std::shared_ptr<VertexArray>& vertexArray);

        // 查询当前渲染API类型
        inline static RendererAPI::APIType GetAPI() { return RendererAPI::GetAPIType(); }

    private:
        // 场景数据缓存：存储每帧全局渲染信息
        struct SceneData { glm::mat4 ViewProjectionMatrix; };
        static SceneData* m_SceneData;
    };
}
```

## 3.2 Renderer.cpp

```cpp
#include "hzpch.h"
#include "Renderer.h"

namespace Hazel {
    Renderer::SceneData* Renderer::m_SceneData = new Renderer::SceneData;

    void Renderer::BeginScene(const OrthographicCamera& camera)
    {
        // 缓存相机预计算的VP矩阵，避免每帧多次获取
        m_SceneData->ViewProjectionMatrix = camera.GetViewProjectionMatrix();
    }

    void Renderer::EndScene() {}

    void Renderer::Submit(const std::shared_ptr<Shader>& shader, const std::shared_ptr<VertexArray>& vertexArray)
    {
        shader->Bind();
        // 上传VP矩阵到Shader的uniform变量（所有物体共享）
        shader->UploadUniformMat4("u_ViewProjection", m_SceneData->ViewProjectionMatrix);
        
        vertexArray->Bind();
        RenderCommand::DrawIndexed(vertexArray); // 执行绘制命令
    }
}
```

# 四、Application 层集成

```cpp
#include "hzpch.h"
#include "Application.h"
#include "OrthographicCamera.h"
#include "Shader.h"
#include "VertexArray.h"
#include "Renderer.h"
#include "Events/WindowEvent.h"

Application::Application()
	:m_Camera(-1.6f, 1.6f, -0.9f, 0.9f)
{
	HZ_CORE_ASSERT(!s_Instance, "Application already exists!");
	s_Instance = this;

	// 创建窗口
	// 创建ImGuiLayer

	// 渲染初始化：VAO、VBO、IBO
	// 顶点数据与布局
	// 1. 创建VBO并设置布局
	// 2. 创建IBO
	// 3. 创建VAO并关联VBO、IBO

	// 创建shader
	// 顶点着色器src
	std::string vertexSrc = R"(
		#version 330 core

		layout(location = 0) in vec3 a_Position;
		layout(location = 1) in vec4 a_Color;

		uniform mat4 u_ViewProjection;

		out vec3 v_Position;
		out vec4 v_Color;

		void main(){
			gl_Position = u_ViewProjection * vec4(a_Position, 1.0f);
			v_Position = a_Position;
			v_Color = a_Color;
		}
	)";
	// 片段着色器
	std::string fragmentSrc = R"(
		#version 330 core

		layout(location = 0) out vec4 color;

		in vec3 v_Position;
		in vec4 v_Color;

		void main(){
			color = vec4(v_Position * 0.5 + 0.5, 1.0f);
			color = v_Color;
		}
	)";

	// Instantiate the main shader to avoid null dereference later in Run()
	m_Shader.reset(new Shader(vertexSrc, fragmentSrc));

	// 创建shader2
	// 顶点着色器src
	std::string blueShaderVertexSrc = R"(
		#version 330 core

		layout(location = 0) in vec3 a_Position;

		uniform mat4 u_ViewProjection;

		out vec3 v_Position;

		void main(){
			gl_Position = u_ViewProjection * vec4(a_Position, 1.0f);
			v_Position = a_Position;
		}
	)";
	// 片段着色器
	std::string blueShaderFragmentSrc = R"(
		#version 330 core

		layout(location = 0) out vec4 color;

		in vec3 v_Position;

		void main(){
			color = vec4(0.2, 0.3, 0.8, 1.0);
		}
	)";

	m_BlueShader.reset(new Shader(blueShaderVertexSrc, blueShaderFragmentSrc));
}

// 主循环
void Application::Run()
{
	while (m_Running)
	{
		// 1. 抽象清屏命令
		RenderCommand::SetClearColor(glm::vec4(0.1f, 0.1f, 0.2f, 1.0f));
		RenderCommand::Clear();

		// set camera position before begin scene so matrix reflects new position
		m_Camera.SetPosition({ 0.5f, 0.5f, 0.5f });

		// 2. 渲染流程
		Renderer::BeginScene(m_Camera);

		// 提交第一个物体
		Renderer::Submit(m_BlueShader, m_SqrVA);

		// 提交第二个物体
		Renderer::Submit(m_Shader, m_VertexArray);

		Renderer::EndScene();

		// 3. Layer更新与ImGui渲染
		for (Layer* layer : m_LayerStack)
			layer->OnUpdate();

		m_ImGuiLayer->Begin();
		for (Layer* layer : m_LayerStack)
			layer->OnImGuiRender();
		m_ImGuiLayer->End();

		m_Window->OnUpdate();
	}

	// 程序退出时，释放OpenGL资源
	m_VertexArray->Unbind();
}
```

# 五、核心逻辑

1. **矩阵计算**：
    - 投影矩阵：`glm::ortho`生成，定义 2D 可视范围；
    - 视图矩阵：相机变换矩阵的逆矩阵（实现 “世界反向移动”）；
    - VP 矩阵：预计算`Projection * View`，减少渲染时计算开销。
2. **渲染流程**：
    - `BeginScene`：缓存相机 VP 矩阵；
    - `Submit`：上传矩阵到 Shader，绑定 VA 并执行绘制；
    - 顶点转换：`gl_Position = u_ViewProjection * vec4(a_Position, 0.0f, 1.0f)`。
3. **核心优势**：
    - 无透视畸变，适配 2D 场景；
    - 接口简洁，矩阵逻辑封装；
    - 预计算优化性能，架构解耦易扩展。

# 六、后续扩展

1. 新增 Model 矩阵，支持物体独立变换；
2. 集成输入系统，实现相机交互（移动 / 旋转）；
3. 添加视锥体剔除，减少无效 DrawCall；
4. 扩展 Shader 支持纹理、颜色定制。