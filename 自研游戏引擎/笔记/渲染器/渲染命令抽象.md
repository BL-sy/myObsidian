---
title: 渲染器
date: 2025-11-17
tags:
  - 自研游戏引擎
  - Cpp
category: 游戏引擎
description: 渲染命令抽象，完成跨平台渲染最后一步
---
---


此前已完成 VertexBuffer、VertexArray、Shader 等渲染资源的抽象，Application 层已脱离大部分平台相关代码，但仍残留 3 句 OpenGL 原生调用（`glClearColor`、`glClear`、`glDrawElements`），这 3 句代码成为跨平台渲染的最后障碍 —— 上层逻辑仍直接依赖 OpenGL，无法无缝切换到 Vulkan/DirectX 等其他 API。

# 一、核心任务

抽象 Application 中最后 3 句 OpenGL 原生代码，彻底移除上层平台依赖，目标替换为平台无关的`RenderCommand`接口：

|原生 OpenGL 代码|抽象后接口|
|---|---|
|`glClearColor(0.1f, 0.1f, 0.1f, 1)`|`RenderCommand::SetClearColor(glm::vec4)`|
|`glClear(GL_COLOR_BUFFER_BIT)`|`RenderCommand::Clear()`|
|`glDrawElements(...)`|`RenderCommand::DrawIndexed(vertexArray)`|

# 二、核心类设计（简洁实现）

## 1. RendererAPI（平台渲染接口基类）

统一不同平台的渲染命令接口，管理渲染 API 类型：

```cpp
// RendererAPI.h
#include <glm/glm.hpp>
#include "VertexArray.h"

namespace Hazel {
    class RendererAPI {
    public:
        // 渲染API类型（从Renderer移至此）
        enum class APIType { None = 0, OpenGL };

        // 纯虚接口：对应3个待抽象的命令
        virtual void SetClearColor(const glm::vec4& color) const = 0;
        virtual void Clear() const = 0;
        virtual void DrawIndexed(const std::shared_ptr<VertexArray>& va) const = 0;

        // 全局获取当前API类型
        inline static APIType GetAPIType() { return s_APIType; }
    private:
        static APIType s_APIType;
    };
}

// RendererAPI.cpp
#include "RendererAPI.h"
Hazel::RendererAPI::APIType Hazel::RendererAPI::s_APIType = Hazel::RendererAPI::APIType::OpenGL;
```

## 2. OpenGLRendererAPI（平台实现）

封装 OpenGL 原生调用，实现`RendererAPI`接口：

```cpp
// OpenGLRendererAPI.h
#include "RendererAPI.h"
#include <glad/glad.h>

namespace Hazel {
    class OpenGLRendererAPI : public RendererAPI {
    public:
        virtual void SetClearColor(const glm::vec4& color) const override {
            glClearColor(color.r, color.g, color.b, color.a);
        }
        virtual void Clear() const override {
            glClear(GL_COLOR_BUFFER_BIT);
        }
        virtual void DrawIndexed(const std::shared_ptr<VertexArray>& va) const override {
            glDrawElements(GL_TRIANGLES, va->GetIndexBuffer()->GetCount(), GL_UNSIGNED_INT, nullptr);
        }
    };
}
```

## 3. RenderCommand（静态命令封装）

提供静态接口，屏蔽`RendererAPI`的实例化细节，为后续命令队列铺路：

```cpp
// RenderCommand.h
#include "RendererAPI.h"

namespace Hazel {
    class RenderCommand {
    public:
        static void SetClearColor(const glm::vec4& color) {
            s_RendererAPI->SetClearColor(color);
        }
        static void Clear() {
            s_RendererAPI->Clear();
        }
        static void DrawIndexed(const std::shared_ptr<VertexArray>& va) {
            s_RendererAPI->DrawIndexed(va);
        }
    private:
        // 初始化时创建对应平台的RendererAPI实例
        static std::unique_ptr<RendererAPI> s_RendererAPI;
    };

    // RenderCommand.cpp 初始化
    std::unique_ptr<RendererAPI> RenderCommand::s_RendererAPI = std::make_unique<OpenGLRendererAPI>();
}
```

## 4. Renderer（渲染统筹类）

简化实现，负责提交渲染数据（绑定 VAO）：

```cpp
// Renderer.h
#include "VertexArray.h"

namespace Hazel {
    class Renderer {
    public:
        static void BeginScene() {} // 预留接口，后续扩展环境设置
        static void EndScene() {}   // 预留接口，后续扩展优化
        static void Submit(const std::shared_ptr<VertexArray>& va) {
            va->Bind(); // 提交时绑定VAO，分离渲染数据准备与命令执行
            RenderCommand::DrawIndexed(va);
        }
        // 复用RendererAPI的API类型查询
        inline static RendererAPI::APIType GetAPI() {
            return RendererAPI::GetAPIType();
        }
    };
}
```

# 三、最终 Application 渲染循环

```cpp
void Application::Run() {
    while (m_Running) {
        // 1. 抽象清屏命令（洋红色作为底层颜色，便于调试）
        RenderCommand::SetClearColor(glm::vec4(1.0f, 0.0f, 1.0f, 1.0f));
        RenderCommand::Clear();

        // 2. 渲染流程（预留Begin/EndScene，当前简化提交）
        Renderer::BeginScene();
        
        // 提交第一个物体
        m_BlueShader->Bind();
        Renderer::Submit(m_SqrVA);

        // 提交第二个物体
        m_Shader->Bind();
        Renderer::Submit(m_VertexArray);

        Renderer::EndScene();

        // 3. Layer更新与ImGui渲染（原有逻辑不变）
        for (Layer* layer : m_LayerStack)
            layer->OnUpdate();

        m_ImGuiLayer->Begin();
        for (Layer* layer : m_LayerStack)
            layer->OnImGuiRender();
        m_ImGuiLayer->End();

        m_Window->OnUpdate();
    }
}
```
