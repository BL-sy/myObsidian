---
title: 输入轮询
date: 2025-11-05
tags:
  - 自研游戏引擎
  - Cpp
category: 游戏引擎
description: 实现自研引擎的输入轮询机制，持续检测键盘、鼠标等设备状态变化，为游戏逻辑提供实时输入数据支撑。
---
---


在游戏引擎开发中，输入事件检测是连接玩家操作与游戏逻辑的核心环节。当引擎功能逐步完善后，我们会面临一个关键需求：
如何在程序任意位置（如游戏逻辑层、UI 层、物理模拟层）快速查询当前输入状态，例如按键是否按下、鼠标位置是否变化等。
本文将以 Hazel 游戏引擎为例，详细讲解基于 GLFW 的输入事件轮询实现思路、代码架构与测试验证，为自研引擎的输入模块开发提供参考。

# 一、需求背景与核心痛点

## 1. 核心目标

实现 “全局可查询” 的输入事件检测能力，让引擎任何代码模块都能通过统一接口，实时获取以下输入信息：
- 键盘按键的按下 / 重复触发状态（如 W、A、S、D 键）；
- 鼠标按钮的按下状态（如左键、右键、中键）；
- 鼠标光标在窗口内的实时坐标（含 X 轴、Y 轴单独查询）。

## 2. 现有方案的局限

在本次优化前，Hazel 引擎已能通过Application类的OnEvent函数接收 GLFW 窗口事件，并将事件分发给对应的Layer（层）进行处理。但这种 “事件分发” 模式存在明显不足：
- **查询范围受限**：仅能在Layer的事件处理函数中响应输入，无法在游戏循环的更新阶段（如Layer::OnUpdate）或其他自定义模块中主动查询输入状态；
- **逻辑耦合度高**：若多个模块需要同一输入信息（如鼠标位置），需重复编写事件接收逻辑，不符合 “单一职责” 设计原则。

# 二、实现思路对比与方案选型

| 实现方案               | 核心逻辑                                                                                   | 优势                                 | 劣势                                                             | 适用性                        |
| ------------------ | -------------------------------------------------------------------------------------- | ---------------------------------- | -------------------------------------------------------------- | -------------------------- |
| 方案一：自定义事件状态管理      | 监听 GLFW 窗口事件，维护一套独立的按键 / 鼠标状态变量（如bool m_KeyPressed[GLFW_KEY_LAST]），事件触发时更新变量，查询时直接读取变量 | 可完全自定义状态逻辑（如添加按键连击判定）              | 需手动处理事件同步、状态重置，代码量较大；易因事件遗漏导致状态异常\|	需深度定制输入逻辑的场景（如格斗游戏的按键组合检测） | 需深度定制输入逻辑的场景（如格斗游戏的按键组合检测） |
| 方案二：基于 GLFW 原生函数封装 | 利用 GLFW 内置的输入查询函数（如glfwGetKey、glfwGetCursorPos），封装为全局可调用的接口，查询时直接调用 GLFW 函数获取实时状态      | 无需维护独立状态，减少代码冗余；依托 GLFW 成熟实现，稳定性更高 | 自定义扩展能力较弱（如无法直接添加按键映射）                                         | 大多数常规游戏场景，追求开发效率与稳定性       |


结合 Hazel 引擎的轻量化定位与快速迭代需求，方案二无需额外维护状态，且能直接复用 GLFW 的跨平台特性，因此成为本次开发的首选方案。以后会自定义Hazel按键

# 三、代码实现：单例模式封装全局输入接口

为确保接口全局可访问且避免重复实例化，我们采用静态**单例模式**设计输入模块，核心分为 “抽象基类定义接口” 与 “平台实现类落地功能” 两层架构，同时兼容 Windows、Linux 等不同平台（本文以 Windows 平台为例）。

## 1. 抽象基类：定义统一输入接口（Input.h）
首先创建Input基类，声明所有输入查询的纯虚函数，作为引擎输入模块的 “接口契约”；同时定义静态单例指针s_Instance，确保全局仅有一个输入实例。
```cpp
//Input.h
#pragma once
#include "Hazel/Core.h"
#include <utility> // 用于std::pair

namespace Hazel {
    class HAZEL_API Input {
    public:
        // 全局静态接口：键盘按键查询（返回是否按下或重复触发）
        inline static bool IsKeyPressed(int keycode) { 
            return s_Instance->IsKeyPressedImpl(keycode); 
        }
        // 全局静态接口：鼠标按钮查询（返回是否按下）
        inline static bool IsMouseButtonPressed(int button) { 
            return s_Instance->IsMouseButtonPressedImpl(button); 
        }
        // 全局静态接口：获取鼠标位置（返回X、Y坐标对）
        inline static std::pair<float, float> GetMousePosition() { 
            return s_Instance->GetMousePositionImpl(); 
        }
        // 全局静态接口：单独获取鼠标X坐标
        inline static float GetMouseX() { 
            return s_Instance->GetMouseXImpl(); 
        }
        // 全局静态接口：单独获取鼠标Y坐标
        inline static float GetMouseY() { 
            return s_Instance->GetMouseYImpl(); 
        }

    protected:
        // 纯虚函数：由平台实现类（如WindowsInput）重写
        virtual bool IsKeyPressedImpl(int keycode) = 0;
        virtual bool IsMouseButtonPressedImpl(int button) = 0;
        virtual std::pair<float, float> GetMousePositionImpl() = 0;
        virtual float GetMouseXImpl() = 0;
        virtual float GetMouseYImpl() = 0;

    private:
        // 静态单例指针：指向具体平台的输入实例（如WindowsInput）
        static Input* s_Instance;
    };
}
```
## 2. 平台实现类：Windows 平台功能落地（WindowsInput.h/.cpp）
创建WindowsInput类继承自Input，重写纯虚函数，通过调用 GLFW 的原生函数实现输入查询逻辑。核心是通过`Application::Get().GetWindow().GetNativeWindow()`获取 GLFW 窗口句柄，再传入 GLFW 函数中获取实时输入状态。
### WindowsInput.h（声明）
```cpp
//WindowsInput.h
#pragma once
#include "Hazel/Input.h"

namespace Hazel {
    class WindowsInput : public Input {
    protected:
        // 重写基类纯虚函数，实现Windows平台的输入查询
        virtual bool IsKeyPressedImpl(int keycode) override;
        virtual bool IsMouseButtonPressedImpl(int button) override;
        virtual std::pair<float, float> GetMousePositionImpl() override;
        virtual float GetMouseXImpl() override;
        virtual float GetMouseYImpl() override;
    };
}
```
### WindowsInput.cpp（实现）
```cpp
//WindowsInput.cpp
#include "hzpch.h"
#include "WindowsInput.h"
#include "Hazel/Application.h"
#include <GLFW/glfw3.h> // 引入GLFW头文件

namespace Hazel {
    // 初始化单例：让基类指针指向Windows平台的输入实例
    Input* Input::s_Instance = new WindowsInput();

    // 键盘按键查询实现：调用glfwGetKey获取状态
    bool WindowsInput::IsKeyPressedImpl(int keycode) {
        // 将引擎封装的窗口句柄转为GLFW原生句柄
        auto window = static_cast<GLFWwindow*>(
            Application::Get().GetWindow().GetNativeWindow()
        );
        // GLFW_KEY_PRESS：单次按下；GLFW_REPEAT：长按重复触发
        auto state = glfwGetKey(window, keycode);
        return state == GLFW_PRESS || state == GLFW_REPEAT;
    }

    // 鼠标按钮查询实现：调用glfwGetMouseButton获取状态
    bool WindowsInput::IsMouseButtonPressedImpl(int button) {
        auto window = static_cast<GLFWwindow*>(
            Application::Get().GetWindow().GetNativeWindow()
        );
        auto state = glfwGetMouseButton(window, button);
        return state == GLFW_PRESS;
    }

    // 鼠标位置查询实现：调用glfwGetCursorPos获取坐标
    std::pair<float, float> WindowsInput::GetMousePositionImpl() {
        auto window = static_cast<GLFWwindow*>(
            Application::Get().GetWindow().GetNativeWindow()
        );
        double xpos, ypos; // GLFW返回double类型，需转为float
        glfwGetCursorPos(window, &xpos, &ypos);
        return { static_cast<float>(xpos), static_cast<float>(ypos) };
    }

    // 单独获取鼠标X坐标：复用GetMousePositionImpl的结果
    float WindowsInput::GetMouseXImpl() {
        // C++17结构化绑定：直接从坐标对中提取X值
        auto [x, y] = GetMousePositionImpl();
        return x;
        // 兼容C++14及以下：使用std::get<0>提取第一个元素
        // auto pos = GetMousePositionImpl();
        // return std::get<0>(pos);
    }

    // 单独获取鼠标Y坐标：同理复用已有逻辑
    float WindowsInput::GetMouseYImpl() {
        auto [x, y] = GetMousePositionImpl();
        return y;
    }
}
```
## 3. 代码设计亮点

- **接口与实现分离**：Input基类定义接口，WindowsInput负责平台实现，后续扩展 Linux/Mac 平台时，只需新增LinuxInput/MacInput类，无需修改已有代码，符合 “开闭原则”；
- **全局访问便捷性**：通过静态成员函数（如Input::IsKeyPressed）直接调用，无需传递输入实例，降低代码耦合；
- **逻辑复用**：GetMouseXImpl与GetMouseYImpl复用GetMousePositionImpl的结果，避免重复调用 GLFW 函数，提升效率。

# 四、测试验证：全局输入查询的实际应用

为验证输入模块的有效性，我们在引擎的主循环（Application::Run）中添加测试代码，实时打印鼠标位置坐标，观察是否能全局获取输入状态。
## 1. 测试代码（Application.cpp）

在主循环的每一帧中，先更新Layer层逻辑，再通过Input::GetMousePosition获取鼠标坐标，并通过日志系统（HZ_CORE_TRACE）打印：
```cpp
void Application::Run() {
    while (m_Running) { // 引擎主循环：持续运行直到窗口关闭
        // 1. 清除屏幕缓冲区（设置背景色为紫色）
        glClearColor(1.0f, 0.0f, 1.0f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // 2. 更新所有Layer层的逻辑（如游戏物体移动、UI刷新）
        for (Layer* layer : m_LayerStack) {
            layer->OnUpdate();
        }

        // 3. 测试：全局查询鼠标位置并打印
        auto [mouseX, mouseY] = Input::GetMousePosition();
        HZ_CORE_TRACE("鼠标位置：X={0}, Y={1}", mouseX, mouseY);

        // 4. 更新GLFW窗口（处理窗口事件、交换缓冲区）
        m_Window->OnUpdate();
    }
}
```
## 2. 测试结果

运行引擎后，日志窗口会持续输出类似以下内容：
```plaintext
[15:59:10] HAZEL: 鼠标位置：X=249, Y=224
[15:59:10] HAZEL: 鼠标位置：X=249, Y=224
[15:59:11] HAZEL: 鼠标位置：X=250, Y=225
[15:59:11] HAZEL: 鼠标位置：X=251, Y=226
```

![[029.webp]]

当移动鼠标时，mouseX与mouseY的值会实时变化，证明：
- 输入模块能在主循环中全局查询鼠标位置；
- 接口返回的坐标与鼠标实际移动一致，状态获取准确。

当引擎基于 GLFW 实现初步输入查询功能后，会面临一个隐藏的 “跨平台陷阱”—— ==直接依赖 GLFW 原生键值定义==，会导致后续扩展平台或更换窗口库时出现兼容性断层。接下来将详细解析这一问题的根源，阐述**自定义键值**方案的设计思路与实现过程，并通过实际测试验证其有效性，为引擎输入模块的跨平台能力打下基础。

# 五、现状与痛点：GLFW 原生键值的局限性

在之前的输入模块开发中，我们通过封装 GLFW 的glfwGetKey等函数，实现了键盘与鼠标输入的全局查询。但此时的输入检测完全**依赖 GLFW 定义的宏**（如GLFW_KEY_A、GLFW_MOUSE_BUTTON_1），在实际开发与跨平台扩展中逐渐暴露两大核心问题：

## 1. 代码耦合度高，依赖边界模糊

直接使用 GLFW 键值时，所有需要检测输入的代码模块（如游戏逻辑层、UI 交互层）都必须包含 GLFW 的头文件（glfw3.h）。这导致引擎核心模块与底层窗口库产生强耦合 —— 若后续因需求变更更换窗口库（如 Windows 平台改用 Win32 API，移动端改用 SDL），所有引用GLFW_KEY_\*的代码都需要修改，维护成本极高。

例如，原本检测 “A 键按下” 的代码如下：
```cpp
// 依赖GLFW头文件的写法，耦合度高
#include <GLFW/glfw3.h>
if (Input::IsKeyPressed(GLFW_KEY_A)) {
    // 执行A键对应的逻辑
}
```
一旦脱离 GLFW 环境，GLFW_KEY_A的定义将失效。

## 2. 跨平台键值不统一，兼容性断层

不同窗口库或操作系统的键值定义存在差异。以 “鼠标左键” 为例：GLFW 中定义为GLFW_MOUSE_BUTTON_1，而 Win32 API 中通过MK_LBUTTON标识，macOS 的 Cocoa 框架又有独立的键值编码。若引擎仅依赖 GLFW 键值，当需要**适配多平台**时，将面临 “**一套输入逻辑，多套键值判断**” 的混乱局面，无法实现 “一次编码，多端运行” 的跨平台目标。

# 六、解决方案：自定义键值体系的设计与实现

为打破 GLFW 原生键值的局限，核心思路是**构建引擎专属的键值抽象层**—— 参考 GLFW 的键值映射逻辑，定义一套与底层窗口库无关的自定义键值（如HZ_KEY_A、HZ_MOUSE_BUTTON_LEFT），再通过输入模块的底层实现，将**自定义键值与当前平台的原生键值进行映射**。这样既能保证上层代码的统一性，又能灵活适配不同底层库。
## 1. 自定义键值宏定义：构建统一抽象层

我们分别创建`KeyCodes.h`和`MouseButtonCodes.h`两个头文件，集中定义引擎的自定义键值。键值的数值参考 GLFW 的定义（避免无意义的数值冲突），命名前缀统一为HZ_（代表引擎名称，如 Hazel），确保与底层库键值区分开。

（1）键盘键值定义（KeyCodes.h）
```cpp
//KeyCodes.h
// 键盘键值：参考GLFW定义，构建引擎自定义键值体系
#define HZ_KEY_UNKNOWN            -1

// 打印键区
#define HZ_KEY_SPACE              32
#define HZ_KEY_APOSTROPHE         39  /* ' */
#define HZ_KEY_COMMA              44  /* , */
#define HZ_KEY_MINUS              45  /* - */
#define HZ_KEY_PERIOD             46  /* . */
#define HZ_KEY_SLASH              47  /* / */
#define HZ_KEY_0                  48
#define HZ_KEY_1                  49
// ...（省略数字键、字母键定义，逻辑与GLFW一致）
#define HZ_KEY_A                  65
#define HZ_KEY_B                  66
#define HZ_KEY_C                  67
// ...（省略其余字母键）

// 功能键
#define HZ_KEY_ESCAPE             256
#define HZ_KEY_ENTER              257
#define HZ_KEY_TAB                258
#define HZ_KEY_BACKSPACE          259
#define HZ_KEY_INSERT             260
#define HZ_KEY_DELETE             261
// ...（省略方向键、功能键F1-F12等定义）
```

（2）鼠标键值定义（MouseButtonCodes.h）
```cpp
//MouseButtonCodes.h
// 鼠标键值：同样参考GLFW，统一命名风格
#define HZ_MOUSE_BUTTON_1         0
#define HZ_MOUSE_BUTTON_2         1
#define HZ_MOUSE_BUTTON_3         2
#define HZ_MOUSE_BUTTON_4         3
#define HZ_MOUSE_BUTTON_5         4
#define HZ_MOUSE_BUTTON_6         5
#define HZ_MOUSE_BUTTON_7         6
#define HZ_MOUSE_BUTTON_8         7

// 常用鼠标按键别名，提升代码可读性
#define HZ_MOUSE_BUTTON_LEFT      HZ_MOUSE_BUTTON_1
#define HZ_MOUSE_BUTTON_RIGHT     HZ_MOUSE_BUTTON_2
#define HZ_MOUSE_BUTTON_MIDDLE    HZ_MOUSE_BUTTON_3
```
## 2. 底层映射：实现自定义键值与原生键值的关联

自定义键值的核心价值，在于底层实现中 “无感映射” 到当前平台的**原生键值**。由于当前引擎仍基于 GLFW 开发，我们只需在WindowsInput（或对应平台的输入实现类）中，直接使用自定义键值作为参数 —— 因为自定义键值的数值与 GLFW 完全一致，无需额外转换，即可直接传入 GLFW 函数。

例如，修改IsKeyPressedImpl方法的参数类型（从int隐性适配为自定义键值）：
```cpp
// WindowsInput.cpp
bool WindowsInput::IsKeyPressedImpl(int keycode) {
    // keycode此时传入的是HZ_KEY_*（如HZ_KEY_A），数值与GLFW_KEY_A一致
    auto window = static_cast<GLFWwindow*>(
        Application::Get().GetWindow().GetNativeWindow()
    );
    auto state = glfwGetKey(window, keycode);
    return state == GLFW_PRESS || state == GLFW_REPEAT;
}
```
若后续更换为 Win32 API，只需在新的平台输入类（如Win32Input）中，添加自定义键值到 Win32 键值的映射表即可，上层代码无需修改：
```cpp
// 未来适配Win32时的映射示例（伪代码）
int Win32Input::MapHzKeyToWin32(int hzKeycode) {
    static std::unordered_map<int, int> keyMap = {
        {HZ_KEY_A, 0x41},    // Win32中A键的虚拟键码是0x41
        {HZ_KEY_ENTER, 0x0D}, // Win32中Enter键的虚拟键码是0x0D
        // ...其他键值映射
    };
    return keyMap.count(hzKeycode) ? keyMap[hzKeycode] : -1;
}
```

# 七、测试验证：自定义键值在实际场景中的应用

为确保自定义键值体系能正常工作，我们在ExampleLayer（引擎的示例层）中，分别在输入轮询（OnUpdate）和事件系统（OnEvent）两个核心场景中进行测试，验证自定义键值的有效性。
## 1. 场景 1：输入轮询（OnUpdate）

在引擎主循环的更新阶段，通过Input::IsKeyPressed直接传入自定义键值HZ_KEY_A，检测 A 键是否按下：
```cpp
// SandboxApp.cpp
void ExampleLayer::OnUpdate() {
    // 使用自定义键值HZ_KEY_A检测A键，无需包含GLFW头文件
    if (Hazel::Input::IsKeyPressed(HZ_KEY_A)) {
        HZ_CORE_TRACE("A键按下(pull)");
    }
    // ...其他更新逻辑
}
```

## 2. 场景 2：事件系统（OnEvent）

在事件回调中，通过KeyPressedEvent的GetKeyCode方法获取自定义键值，判断是否为目标按键：
```cpp
// SandboxApp.cpp
void OnEvent(Hazel::Event& event) override 
{
    //HZ_TRACE("{0}",event.ToString());
    if(event.GetEventType() == Hazel::EventType::KeyPressed)
    {
        Hazel::KeyPressedEvent& e = (Hazel::KeyPressedEvent&)event;
        if (e.GetKeyCode() == HZ_KEY_A)
        {
            HZ_TRACE("A键按下(event)");
        }
    }
}
```

## 3. 测试结果

运行引擎后，日志窗口输出如下内容，证明自定义键值在两种场景下均能正常工作：
```plaintext
[16:30:05] HAZEL: A键按下(event)
[16:30:05] HAZEL: A键按下(poll)
[16:30:06] HAZEL: A键按下(poll)
[16:30:06] HAZEL: A键按下(poll)
```
同时，代码中无需包含glfw3.h，彻底解除了对 GLFW 的直接依赖，为后续跨平台扩展扫清障碍。

# 八、总结与扩展方向

本次开发通过 “GLFW 函数封装 + 单例模式”，成功实现了 Hazel 引擎的全局输入事件轮询功能，解决了原有事件分发模式的查询范围受限问题。通过构建自定义键值体系，成功解决了 GLFW 原生键值带来的耦合与兼容性问题，其核心价值体现在三个方面：

- **解耦底层依赖**：上层代码**仅依赖引擎自定义键值**，无需关注底层窗口库，降低维护成本；
- **统一跨平台接口**：无论后续适配 Win32、SDL 还是移动端库，只需修改底层映射，上层逻辑保持不变；
- **提升代码可读性**：通过HZ_MOUSE_BUTTON_LEFT等别名，让代码意图更清晰（相比GLFW_MOUSE_BUTTON_1更易理解）。

后续可基于该体系进一步扩展：

- **添加键值映射配置文件**：将键值映射逻辑从代码中抽离到配置文件（如 JSON），支持动态修改键值对应关系，适配不同玩家的操作习惯；
- **扩展游戏手柄键值**：参考键盘与鼠标的设计，定义GamepadCodes.h，支持手柄按键（如HZ_GAMEPAD_BUTTON_A）的统一检测；
- **实现键值别名管理**：允许开发者为同一键值设置多个别名（如HZ_KEY_JUMP映射到HZ_KEY_SPACE），让游戏逻辑与物理按键解耦，提升代码灵活性。
- **游戏手柄支持**：通过 GLFW 的glfwGetGamepadState函数，扩展手柄按键与摇杆的查询功能，覆盖更多输入设备场景。


# 附：深入理解核心调用 `Application::Get().GetWindow().GetNativeWindow()`

在本次输入模块开发中，`Application::Get().GetWindow().GetNativeWindow()` 是连接引擎封装层与底层 GLFW 库的 “关键桥梁”。这句链式调用并非随意组合，而是基于引擎架构的逻辑依赖设计，其核心作用是获取**底层窗口的原生句柄**，为 GLFW 函数提供 “操作目标”，具体拆解如下：

## 一）调用逻辑：三层递进的 “资源定位”

这句代码的本质是 “从全局到局部” 的资源定位，每一步都对应引擎架构的特定层级，顺序不可颠倒：
### 1. `Application::Get()`：锁定引擎全局核心
Application 是引擎的 **“单例核心类”**，负责管理生命周期、窗口、图层栈等全局资源。Get() 作为**静态方法**，能直接获取全局唯一的引擎实例 —— 这是后续所有资源访问的 “起点”，确保我们操作的是当前运行的引擎主进程。

### 2. `.GetWindow()`：获取封装后的窗口对象
引擎会通过 Application 内部的 m_Window 成员变量，持有一个**封装后的 Window 类实例**。这个 Window 类隐藏了**不同平台的底层差异**（如 Windows 的 HWND、macOS 的 NSWindow），对外提供**统一的窗口操作接口**（如创建、改标题）。调用 GetWindow()，就是从引擎核心中取出这个 “统一窗口对象”。

### 3. `.GetNativeWindow()`：穿透封装，拿到**底层句柄**
Window 类作为抽象基类，会由平台实现类（如 WindowsWindow）重写 GetNativeWindow() 方法 —— 在 Windows+GLFW 场景下，该方法会**返回 GLFW 库的原生窗口句柄** GLFWwindow*。这一步是 “破封装” 的关键，让我们能拿到 GLFW 函数需要的 “原始标识”。

## 二）核心作用：为 GLFW 函数提供 “操作目标”

GLFW 的所有窗口相关函数（如输入检测 glfwGetKey、鼠标位置查询 glfwGetCursorPos），都需要传入 **GLFWwindow\* 句柄**，明确 “对哪个窗口进行操作”。而 `Application::Get().GetWindow().GetNativeWindow()` 的最终目的，就是将**引擎封装的窗口**，转换为 **GLFW 能识别的 GLFWwindow\* 句柄**。
以输入检测代码为例，这句调用的实际价值一目了然：
```cpp
// 1. 通过链式调用获取GLFW原生句柄
auto window = static_cast<GLFWwindow*>(
    Application::Get().GetWindow().GetNativeWindow()
);
// 2. 传入句柄，调用GLFW函数检测按键
auto state = glfwGetKey(window, keycode);
```
若没有这句调用，GLFW 无法定位 “要检测哪个窗口的输入”，函数将失去作用 —— 这也是它成为输入模块实现 “核心依赖” 的原因。

## 三）总结：引擎架构的 “分层设计体现”

这句链式调用本质是引擎 “分层封装” 理念的体现：
- 上层（Application）负责全局资源管理，确保统一性；
- 中层（Window）负责平台差异封装，提供统一接口；
- 下层（GetNativeWindow()）负责破封装，对接底层库。

三者配合，既实现了跨平台扩展性，又能灵活调用底层功能，是自研引擎中 “封装与交互平衡” 的典型设计。